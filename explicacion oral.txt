ğŸ”¸ Â¿QuÃ© hace su programa?
Toma una expresiÃ³n regular como input (por ejemplo, (ab + ba)) y construye automÃ¡ticamente su autÃ³mata finito no determinista con transiciones Î», utilizando el algoritmo de Kleene (solo la ida, no vuelta).

ğŸ”¸ Â¿CÃ³mo manejan la concatenaciÃ³n implÃ­cita?
Antes de construir el autÃ³mata, transformamos las expresiones como ab en a.b, agregando puntos explÃ­citos. Esto facilita separar las subexpresiones.

ğŸ”¸ Â¿CÃ³mo identifican quÃ© parte de la expresiÃ³n aplicar: uniÃ³n, concatenaciÃ³n o estrella?
Recorremos la expresiÃ³n con cuidado, controlando los niveles de parÃ©ntesis. Detectamos:

+ a nivel superficial â†’ uniÃ³n

. â†’ concatenaciÃ³n

* al final â†’ estrella de Kleene

ğŸ”¸ Â¿QuÃ© representa cada estado en su cÃ³digo?
Cada estado es un nÃºmero Ãºnico generado con new_state(). Hay uno inicial y uno final por cada sub-AFN. Luego, segÃºn el operador (+, *, etc.), se conectan entre sÃ­ con transiciones Î».

ğŸ”¸ Â¿QuÃ© muestra el grÃ¡fico generado?
El grÃ¡fico muestra los estados (cÃ­rculos) y transiciones (flechas etiquetadas).

El estado inicial estÃ¡ en verde.

El final es doble cÃ­rculo.

Las transiciones vacÃ­as se marcan como Î».

ğŸ”¸ Â¿QuÃ© librerÃ­as usan?
Solo usamos graphviz, que permite dibujar el grafo en formato PNG y visualizarlo automÃ¡ticamente. TambiÃ©n usamos solo funciones estÃ¡ndar de Python.

ğŸ”¸ Â¿CÃ³mo funciona la estrella de Kleene en su implementaciÃ³n?
Cuando una subexpresiÃ³n tiene *, el autÃ³mata que la representa se adapta para poder repetirla cero o mÃ¡s veces.
Creamos un nuevo estado inicial y final. Desde el inicial:

Puede ir al autÃ³mata de la subexpresiÃ³n.

O directamente al final (caso "cero repeticiones").

Y desde el final de la subexpresiÃ³n:

Puede volver a empezar.

O ir al estado final.

Todo eso se hace con transiciones Î» (vacÃ­as).

ğŸ”¸ Â¿QuÃ© hace si se ingresa una expresiÃ³n invÃ¡lida?
Si la expresiÃ³n no se puede descomponer correctamente segÃºn el algoritmo (por ejemplo, si faltan parÃ©ntesis), el programa lanza una excepciÃ³n con un mensaje de error:
"ExpresiÃ³n no vÃ¡lida o no reconocida: ..."

ğŸ”¸ Â¿QuÃ© es una transiciÃ³n Î» y por quÃ© se usa?
Es una transiciÃ³n que no consume sÃ­mbolos. Se usa para unir sub-autÃ³matas sin necesidad de consumir un carÃ¡cter.
Por ejemplo, para hacer uniones (+), o repetir algo (*), necesitamos conectar estados sin consumir nada del input. Para eso usamos Î».


ğŸ”¸ Â¿CÃ³mo diferencia el programa entre una concatenaciÃ³n y una uniÃ³n?
Al principio del cÃ³digo usamos una funciÃ³n que inserta concatenaciones explÃ­citas (.).
Por ejemplo, la ER ab+c se convierte en a.b+c.
Esto permite al parser saber cuÃ¡ndo dos sÃ­mbolos estÃ¡n "pegados" (concatenaciÃ³n) y cuÃ¡ndo hay una uniÃ³n (+).

ğŸ”¸ Â¿QuÃ© significa cada uno de los sÃ­mbolos que usa el programa?
SÃ­mbolo	Significado
a, b, ...	sÃ­mbolos del alfabeto
+	uniÃ³n (or)
.	concatenaciÃ³n explÃ­cita
*	estrella de Kleene (repeticiÃ³n cero o mÃ¡s veces)
Î»	transiciÃ³n vacÃ­a (no consume sÃ­mbolo)
()	agrupaciÃ³n de subexpresiones

ğŸ”¸ Â¿Por quÃ© se usa una pila para construir el autÃ³mata?
Porque estamos evaluando una expresiÃ³n posfija (tambiÃ©n conocida como notaciÃ³n polaca inversa).
En esa notaciÃ³n, al encontrar un operador (*, ., +), simplemente tomamos uno o dos operandos (autÃ³matas) de la pila y construimos el nuevo autÃ³mata.
Esto facilita la evaluaciÃ³n sin ambigÃ¼edad ni necesidad de priorizar operadores.
ğŸ§© Â¿DÃ³nde estÃ¡ la â€œpila ocultaâ€?
La "pila" en tu cÃ³digo estÃ¡ implÃ­cita en las llamadas recursivas a la funciÃ³n kleene_recursive. En Python (como en muchos lenguajes), cada llamada a una funciÃ³n se guarda en la pila de llamadas (call stack) del sistema.

ğŸ“Œ Â¿CÃ³mo simula una pila la funciÃ³n kleene_recursive?
Cada vez que la funciÃ³n encuentra algo como un ( o un operador +, * o .:

Llama a sÃ­ misma con una subexpresiÃ³n.

Espera que esa llamada le devuelva el NFA de esa subexpresiÃ³n.

Usa ese resultado para construir algo mÃ¡s complejo.

Todo eso se hace por medio de la pila de llamadas de Python.

âœ¨ Ejemplo:
Supongamos que ingresÃ¡s:

plaintext
Copiar
Editar
(a+b)*.a
hash(expr) transforma la expresiÃ³n (si hay #).

draw_nfa llama a kleene_recursive("((a+b)*.a)")

kleene_recursive:

Encuentra los parÃ©ntesis â†’ llama a sÃ­ misma con "a+b" â†’ espera el resultado.

Luego encuentra * â†’ llama a kleene_star(...) con el resultado anterior.

Luego encuentra . â†’ llama a concatenate(...) con el resultado anterior y con a (otro llamado a kleene_recursive('a')).

Cada uno de estos pasos usa la pila del sistema para ir resolviendo desde lo mÃ¡s interno a lo externo.


ğŸ”¸ Â¿QuÃ© hace el programa si hay mÃ¡s de un + o * seguidos?
Como usamos la notaciÃ³n posfija, se respeta la precedencia y agrupaciÃ³n correcta.
Por ejemplo, (a+b)*c se convierte en a b + * c ., y el orden correcto se mantiene al construir autÃ³matas.


ğŸ”¸ Â¿CÃ³mo estÃ¡ estructurado el cÃ³digo?
EstÃ¡ dividido en partes:

Preprocesamiento: agrega puntos . entre sÃ­mbolos que deben ser concatenados.

ConversiÃ³n a posfija: transforma la expresiÃ³n infija a posfija con el algoritmo de Shunting Yard.

ConstrucciÃ³n del autÃ³mata: usa una pila y operadores para construir el autÃ³mata paso a paso.

GraficaciÃ³n: usa graphviz para mostrar el diagrama del autÃ³mata.

ğŸ”¸ Â¿QuÃ© complejidad tiene el algoritmo?
Depende de la longitud de la expresiÃ³n regular.
La conversiÃ³n a posfija es O(n), y la construcciÃ³n del autÃ³mata tambiÃ©n es O(n), donde n es la cantidad de sÃ­mbolos y operadores.
En general es eficiente para expresiones regulares normales (no muy grandes).